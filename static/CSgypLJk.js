import{au as bt,av as Dt,aw as yt,ax as At,ay as ht,az as Tt,aA as xt,aB as x,aC as H,aD as Ct,aE as Pt,aF as Gt,aG as Lt,aH as St,aI as Bt,aJ as d,aK as lt,aL as v,aM as h,aN as j,aO as f,aP as Ft,aQ as Mt,aR as Rt,aS as Ot,aT as Et,aU as _t,aV as kt,aW as It,aX as vt,R as C,S as P,m as y,k as B,j as I,t as D,P as Ut,aY as Vt,aZ as zt,d as U,a as V,s as F,g as M,M as Nt,L as ut,U as wt,O as jt,p as Ht,T as Wt,i as pt,h as Xt}from"./DR9_mXdV.js";import{b as Yt,g as Jt,d as qt,e as Kt,f as Qt,h as Zt,i as te,j as ee,k as ae,l as et,m as re,n as ie,o as se,p as oe,c as ne,q as le,a as ue}from"./D_lgk1xP.js";import{c as pe}from"./DFcKe5E3.js";import{c as ce,a as me}from"./5i4WpBDy.js";function at(){for(var n=[],i=0;i<arguments.length;i++)n[i]=arguments[i];var s=bt(n),e=Dt(n),r=e.args,p=e.keys,l=new At(function(u){var t=r.length;if(!t){u.complete();return}for(var a=new Array(t),o=t,c=t,m=function(b){var g=!1;ht(r[b]).subscribe(Tt(u,function(G){g||(g=!0,c--),a[b]=G},function(){return o--},void 0,function(){(!o||!g)&&(c||u.next(p?xt(p,a):a),u.complete())}))},$=0;$<t;$++)m($)});return s?l.pipe(yt(s)):l}const de=n=>{const i=x(n,{visibleFilter:{toBeTypes:["Function"]},gridList:{toBeTypes:["object[]"]},container:{toBeTypes:["object"]},separateGrid:{toBeTypes:["boolean"]}});if(n.gridList){const e=n.gridList.map((r,p)=>{const l=x(r,{seriesDirection:{toBe:'"row" | "column"',test:u=>u==="row"||u==="column"},rowLabels:{toBeTypes:["string[]"]},columnLabels:{toBeTypes:["string[]"]},valueAxis:{toBeTypes:["object"]},groupAxis:{toBeTypes:["object"]},separateSeries:{toBeTypes:["boolean"]}});if(l.status==="error")return l;if(r.valueAxis){const u=x(r.valueAxis,{position:{toBe:'"top" | "bottom" | "left" | "right"',test:t=>t==="top"||t==="bottom"||t==="left"||t==="right"},scaleDomain:{toBe:'[number | "min" | "auto", number | "max" | "auto"]',test:t=>Array.isArray(t)&&t.length===2&&(typeof t[0]=="number"||t[0]==="min"||t[0]==="auto")&&(typeof t[1]=="number"||t[1]==="max"||t[1]==="auto")},scaleRange:{toBe:"[number, number]",test:t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="number"&&typeof t[1]=="number"},label:{toBeTypes:["string"]}});if(u.status==="error")return u}else if(r.groupAxis){const u=x(r.groupAxis,{position:{toBe:'"top" | "bottom" | "left" | "right"',test:t=>t==="top"||t==="bottom"||t==="left"||t==="right"},scaleDomain:{toBe:'[number, number | "max"]',test:t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="number"&&(typeof t[1]=="number"||t[1]==="max")},scalePadding:{toBeTypes:["number"]},label:{toBeTypes:["string"]}});if(u.status==="error")return u}return{status:"success",columnName:"",expectToBe:""}}).find(r=>r.status==="error");if(e)return e}if(n.container){const s=x(n.container,{columnAmount:{toBeTypes:["number"]},rowAmount:{toBeTypes:["number"]},columnGap:{toBe:'"auto" | number',test:e=>e==="auto"||typeof e=="number"},rowGap:{toBe:'"auto" | number',test:e=>e==="auto"||typeof e=="number"}});if(s.status==="error")return s}return i},$e=n=>{const{data:i=[],dataFormatter:s,chartParams:e}=n;if(!i.length)return[];let r=[];try{const p=s.gridList[0]||H,l=i.map((c,m)=>s.gridList[m]||p),u=i.map((c,m)=>Yt(c,l[m])),t=s.separateGrid?u.map((c,m)=>Ct({transposedDataGrid:c,dataFormatterGrid:l[m],chartType:"multiGrid"})):u.map((c,m)=>Pt({transposedDataGrid:c,dataFormatterGrid:l[m],chartType:"multiGrid",gridIndex:m})),a=new Map;let o=0;t.flat().forEach((c,m)=>{if(!a.has(c)){const $=Gt(o,e);a.set(c,$),o++}}),r=u.map((c,m)=>{const $=t[m],b=Lt({transposedDataGrid:c,dataFormatterGrid:l[m],chartType:"multiGrid",gridIndex:m});let g=0;return c.map((O,L)=>O.map((A,T)=>{const E=St("multiGrid",m,L,T),z=b[T],_=$[L],S={id:A.id?A.id:E,index:g,label:A.label?A.label:E,description:A.description??"",data:A.data,value:A.value,gridIndex:m,seriesIndex:L,seriesLabel:_,groupIndex:T,groupLabel:z,color:a.get(_),visible:!0};return S.visible=s.visibleFilter(S,n),g++,S}))})}catch(p){throw Error(p)}return r},ge=n=>x({data:n},{data:{toBe:"DataGrid[]",test:s=>Array.isArray(s)}}),fe=({fullDataFormatter$:n,computedData$:i,layout$:s,fullChartParams$:e,event$:r,containerSize$:p})=>{const l=new Bt,u=ct({computedData$:i,fullDataFormatter$:n,layout$:s}).pipe(d(1));return lt({fullDataFormatter:n,computedData:i,multiGridContainer:u}).pipe(v(async t=>t),h(t=>{l.next(void 0);const a=t.fullDataFormatter.gridList[0]??H;return t.computedData.map((o,c)=>{const m=t.fullDataFormatter.gridList[c]??a,$={type:"grid",visibleFilter:t.fullDataFormatter.visibleFilter,...m,container:{...t.fullDataFormatter.container}},b=j($).pipe(f(l),d(1)),g=j(o).pipe(f(l),d(1)),G=b.pipe(h(w=>w.separateSeries),Ft(),d(1)),O=j(t.multiGridContainer[c]).pipe(f(l),d(1)),L=Jt({fullDataFormatter$:b,layout$:s}).pipe(f(l),d(1)),A=qt({fullDataFormatter$:b,containerSize$:p}).pipe(d(1)),T=g.pipe(h(w=>w.flat())).pipe(f(l),d(1)),E=Kt({computedData$:g}).pipe(f(l),d(1)),z=Mt({datumList$:T}).pipe(f(l),d(1)),_=Rt({datumList$:T}).pipe(f(l),d(1)),S=Qt({computedData$:g}).pipe(f(l),d(1)),K=Zt({computedData$:g,fullDataFormatter$:b,layout$:s}).pipe(f(l),d(1)),dt=te({computedAxesData$:K}).pipe(f(l),d(1)),Q=ee({computedData$:g,isSeriesSeprate$:G}).pipe(d(1)),k=ae({computedData$:g,fullDataFormatter$:b}).pipe(f(l),d(1)),Z=et({computedData$:g,groupScaleDomainValue$:k}).pipe(f(l),d(1)),$t=et({computedData$:Q,groupScaleDomainValue$:k}).pipe(f(l),d(1)),N=re({fullDataFormatter$:b,layout$:s}).pipe(f(l),d(1)),gt=ie({gridAxesTransform$:N}).pipe(f(l),d(1)),tt=se({computedData$:g,groupScaleDomainValue$:k,filteredMinMaxValue$:Z,fullDataFormatter$:b,layout$:s}).pipe(f(l),d(1)),ft=oe({gridContainerPosition$:O,gridAxesTransform$:N,gridGraphicTransform$:tt});return{isSeriesSeprate$:G,gridContainerPosition$:O,gridAxesSize$:L,gridAxesContainerSize$:A,seriesLabels$:E,SeriesDataMap$:z,GroupDataMap$:_,dataFormatter$:b,computedData$:g,computedAxesData$:K,visibleComputedData$:S,visibleComputedAxesData$:dt,computedStackedData$:Q,groupScaleDomainValue$:k,filteredMinMaxValue$:Z,filteredStackedMinMaxValue$:$t,gridAxesTransform$:N,gridAxesReverseTransform$:gt,gridGraphicTransform$:tt,gridGraphicReverseScale$:ft}})}))},ct=({computedData$:n,fullDataFormatter$:i,layout$:s})=>lt({computedData:n,fullDataFormatter:i,layout:s}).pipe(v(async e=>e),h(e=>{const r=e.fullDataFormatter.gridList[0]??H,p=e.computedData.reduce((a,o,c)=>{const $=(e.fullDataFormatter.gridList[c]??r).separateSeries?o.length:e.fullDataFormatter.separateGrid?1:0;return a+$},0)||1,l=Ot(e.layout,e.fullDataFormatter.container,p);let u=0;return e.computedData.map((a,o)=>{const c=e.fullDataFormatter.gridList[o]??r,m=a.map(($,b)=>{const g=l[u];return c.separateSeries&&(u+=1),g});return!c.separateSeries&&e.fullDataFormatter.separateGrid&&(u+=1),m})})),be=({subject:n,observer:i})=>{const s=Et(i.fullChartParams$).pipe(d(1)),e=ct({computedData$:i.computedData$,fullDataFormatter$:i.fullDataFormatter$,layout$:i.layout$}).pipe(d(1)),r=_t({layout$:i.layout$,containerPosition$:e.pipe(h(a=>a.flat())),container$:i.fullDataFormatter$.pipe(h(a=>a.container))}).pipe(d(1)),p=kt({datumList$:i.computedData$.pipe(h(a=>a.flat().flat()),d(1)),fullChartParams$:i.fullChartParams$,event$:n.event$}).pipe(d(1)),l=fe({fullDataFormatter$:i.fullDataFormatter$,computedData$:i.computedData$,layout$:i.layout$,fullChartParams$:i.fullChartParams$,event$:n.event$,containerSize$:r}).pipe(d(1)),u=l.pipe(v(a=>at(a.map((o,c)=>o.filteredMinMaxValue$))),h(a=>[Math.min(...a.map(o=>o[0])),Math.max(...a.map(o=>o[1]))])),t=l.pipe(v(a=>at(a.map((o,c)=>o.filteredStackedMinMaxValue$))),h(a=>[Math.min(...a.map(o=>o[0])),Math.max(...a.map(o=>o[1]))]));return{fullParams$:i.fullParams$,fullChartParams$:i.fullChartParams$,fullDataFormatter$:i.fullDataFormatter$,computedData$:i.computedData$,layout$:i.layout$,textSizePx$:s,containerSize$:r,multiGridHighlight$:p,multiGridContainerPosition$:e,filteredMinMaxValue$:u,filteredStackedMinMaxValue$:t,multiGridEachDetail$:l}};class Se extends It{constructor(i,s){super({defaultDataFormatter:vt,dataFormatterValidator:de,computedDataFn:$e,dataValidator:ge,contextObserverCallback:be},i,s)}}const mt="MultiGridLegend",De={name:mt,defaultParams:Ut,layerIndex:Vt,validator:(n,{validateColumns:i})=>{const s=i(n,{placement:{toBe:'"top" | "top-start" | "top-end" | "bottom" | "bottom-start" | "bottom-end" | "left" | "left-start" | "left-end" | "right" | "right-start" | "right-end"',test:e=>["top","top-start","top-end","bottom","bottom-start","bottom-end","left","left-start","left-end","right","right-start","right-end"].includes(e)},padding:{toBeTypes:["number"]},backgroundFill:{toBeOption:"ColorType"},backgroundStroke:{toBeOption:"ColorType"},gap:{toBeTypes:["number"]},listRectWidth:{toBeTypes:["number"]},listRectHeight:{toBeTypes:["number"]},listRectRadius:{toBeTypes:["number"]},gridList:{toBeTypes:["object[]"]},textColorType:{toBeOption:"ColorType"}});if(n.gridList){const r=n.gridList.map((p,l)=>i(p,{listRectWidth:{toBeTypes:["number"]},listRectHeight:{toBeTypes:["number"]},listRectRadius:{toBeTypes:["number"]}})).find(p=>p.status==="error");if(r)return r}return s}},Be=C(De)(({selection:n,rootSelection:i,observer:s,subject:e})=>{const r=new P,p=s.multiGridEachDetail$.pipe(y(a=>a.map(o=>o.seriesLabels$)),B(a=>I(a).pipe(B(async o=>o))),y(a=>a.flat())),l=I({fullParams:s.fullParams$,computedData:s.computedData$}).pipe(D(r),B(async a=>a),y(a=>a.computedData.map((o,c)=>{const m=zt(a.fullParams.gridList[c]??{},{listRectWidth:a.fullParams.listRectWidth,listRectHeight:a.fullParams.listRectHeight,listRectRadius:a.fullParams.listRectRadius});return o.map($=>m)}).flat())),u=I({fullParams:s.fullParams$,seriesList:l}).pipe(D(r),B(async a=>a),y(a=>({...a.fullParams,labelList:a.seriesList}))),t=pe(mt,{rootSelection:i,legendLabels$:p,fullParams$:u,layout$:s.layout$,fullChartParams$:s.fullChartParams$,textSizePx$:s.textSizePx$});return()=>{r.next(void 0),t()}}),R=n=>{const i=n.fullParams$.pipe(y(s=>s.gridIndexes),U(),V(1));return I({multiGridEachDetail:n.multiGridEachDetail$,gridIndexes:i}).pipe(B(async s=>s),y(s=>s.gridIndexes==="all"?s.multiGridEachDetail:s.gridIndexes.map(e=>s.multiGridEachDetail[e]??s.multiGridEachDetail[0])))},W="MultiBars",rt=M(W,"grid"),ye={name:W,defaultParams:Nt,layerIndex:ut,validator:(n,{validateColumns:i})=>i(n,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(r=>typeof r=="number")},barWidth:{toBeTypes:["number"]},barPadding:{toBeTypes:["number"]},barGroupPadding:{toBeTypes:["number"]},barRadius:{toBeTypes:["number","boolean"]}})},Fe=C(ye)(({selection:n,name:i,subject:s,observer:e})=>{const r=new P,p=[];return R(e).pipe(D(r)).subscribe(u=>{p.forEach(t=>t()),n.selectAll(`g.${rt}`).data(u).join("g").attr("class",rt).each((t,a,o)=>{const c=F(o[a]),m=t.dataFormatter$.pipe(D(r),y($=>$.separateSeries),U(),V(1));p[a]=ne(W,{selection:c,computedData$:t.computedData$,visibleComputedData$:t.visibleComputedData$,computedAxesData$:t.computedAxesData$,visibleComputedAxesData$:t.visibleComputedAxesData$,seriesLabels$:t.seriesLabels$,SeriesDataMap$:t.SeriesDataMap$,GroupDataMap$:t.GroupDataMap$,fullParams$:e.fullParams$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridGraphicTransform$:t.gridGraphicTransform$,gridGraphicReverseScale$:t.gridGraphicReverseScale$,gridAxesSize$:t.gridAxesSize$,gridHighlight$:e.multiGridHighlight$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:m,event$:s.event$})})}),()=>{r.next(void 0),p.forEach(u=>u())}}),X="MultiLines",it=M(X,"grid"),Ae={name:X,defaultParams:wt,layerIndex:ut,validator:(n,{validateColumns:i})=>i(n,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(r=>typeof r=="number")},lineCurve:{toBeTypes:["string"]},lineWidth:{toBeTypes:["number"]}})},Me=C(Ae)(({selection:n,rootSelection:i,name:s,subject:e,observer:r})=>{const p=new P,l=[],u=r.multiGridContainerPosition$.pipe(D(p),y(a=>a.flat()));return R(r).pipe(D(p)).subscribe(a=>{l.forEach(o=>o()),n.selectAll(`g.${it}`).data(a).join("g").attr("class",it).each((o,c,m)=>{const $=F(m[c]);l[c]=ce(X,{selection:$,computedData$:o.computedData$,computedAxesData$:o.computedAxesData$,visibleComputedData$:o.visibleComputedData$,visibleComputedAxesData$:o.visibleComputedAxesData$,seriesLabels$:o.seriesLabels$,SeriesDataMap$:o.SeriesDataMap$,GroupDataMap$:o.GroupDataMap$,fullDataFormatter$:o.dataFormatter$,fullParams$:r.fullParams$,fullChartParams$:r.fullChartParams$,gridAxesTransform$:o.gridAxesTransform$,gridGraphicTransform$:o.gridGraphicTransform$,gridAxesSize$:o.gridAxesSize$,gridHighlight$:r.multiGridHighlight$,gridContainerPosition$:o.gridContainerPosition$,allContainerPosition$:u,layout$:r.layout$,event$:e.event$})})}),()=>{p.next(void 0),l.forEach(a=>a())}}),Y="MultiDots",st=M(Y,"grid"),he={name:Y,defaultParams:jt,layerIndex:Ht,validator:(n,{validateColumns:i})=>i(n,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(r=>typeof r=="number")},radius:{toBeTypes:["number"]},fillColorType:{toBeOption:"ColorType"},strokeColorType:{toBeOption:"ColorType"},strokeWidth:{toBeTypes:["number"]},onlyShowHighlighted:{toBeTypes:["boolean"]}})},Re=C(he)(({selection:n,name:i,subject:s,observer:e})=>{const r=new P,p=[];return R(e).pipe(D(r)).subscribe(u=>{p.forEach(t=>t()),n.selectAll(`g.${st}`).data(u).join("g").attr("class",st).each((t,a,o)=>{const c=F(o[a]);p[a]=me(Y,{selection:c,computedData$:t.computedData$,visibleComputedData$:t.visibleComputedData$,computedAxesData$:t.computedAxesData$,visibleComputedAxesData$:t.visibleComputedAxesData$,seriesLabels$:t.seriesLabels$,SeriesDataMap$:t.SeriesDataMap$,GroupDataMap$:t.GroupDataMap$,fullParams$:e.fullParams$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridGraphicTransform$:t.gridGraphicTransform$,gridGraphicReverseScale$:t.gridGraphicReverseScale$,gridAxesSize$:t.gridAxesSize$,gridHighlight$:e.multiGridHighlight$,gridContainerPosition$:t.gridContainerPosition$,event$:s.event$})})}),()=>{r.next(void 0),p.forEach(u=>u())}}),J="MultiGroupAxis",ot=M(J,"grid"),Te={name:J,defaultParams:Wt,layerIndex:pt,validator:(n,{validateColumns:i})=>i(n,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(r=>typeof r=="number")},labelOffset:{toBe:"[number, number]",test:e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="number"&&typeof e[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBe:'number | null | "all"',test:e=>e===null||e==="all"||typeof e=="number"},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}})},Oe=C(Te)(({selection:n,name:i,subject:s,observer:e})=>{const r=new P,p=[];return R(e).pipe(D(r)).subscribe(u=>{p.forEach(t=>t()),n.selectAll(`g.${ot}`).data(u).join("g").attr("class",ot).each((t,a,o)=>{const c=F(o[a]),m=t.dataFormatter$.pipe(D(r),y($=>$.separateSeries),U(),V(1));p[a]=le(J,{selection:c,computedData$:t.computedData$,fullParams$:e.fullParams$,fullDataFormatter$:t.dataFormatter$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridAxesReverseTransform$:t.gridAxesReverseTransform$,gridAxesSize$:t.gridAxesSize$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:m,textSizePx$:e.textSizePx$})})}),()=>{r.next(void 0),p.forEach(u=>u())}}),q="MultiValueAxis",nt=M(q,"grid"),xe={name:q,defaultParams:Xt,layerIndex:pt,validator:(n,{validateColumns:i})=>i(n,{gridIndexes:{toBe:'number[] | "all"',test:e=>e==="all"||Array.isArray(e)&&e.every(r=>typeof r=="number")},labelOffset:{toBe:"[number, number]",test:e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="number"&&typeof e[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBeTypes:["number","null"]},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}})},Ee=C(xe)(({selection:n,name:i,subject:s,observer:e})=>{const r=new P,p=[];return R(e).pipe(D(r)).subscribe(u=>{p.forEach(t=>t()),n.selectAll(`g.${nt}`).data(u).join("g").attr("class",nt).each((t,a,o)=>{const c=F(o[a]),m=t.dataFormatter$.pipe(D(r),y($=>$.separateSeries),U(),V(1));p[a]=ue(q,{selection:c,computedData$:t.computedData$,filteredMinMaxValue$:t.filteredMinMaxValue$,fullParams$:e.fullParams$,fullDataFormatter$:t.dataFormatter$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridAxesReverseTransform$:t.gridAxesReverseTransform$,gridAxesSize$:t.gridAxesSize$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:m})})}),()=>{r.next(void 0),p.forEach(u=>u())}});export{Fe as M,Re as a,Be as b,Oe as c,Me as d,Ee as e,Se as f,R as m};
