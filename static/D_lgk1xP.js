import{aD as he,bB as Ae,aH as Se,aF as ve,bC as De,aK as E,aL as H,aM as W,aI as te,aP as ee,ax as ie,aO as re,aS as ce,bD as ye,bE as ue,bF as Le,m as v,a as j,j as T,k as $,s as X,d as F,S as Q,as as q,t as k,bG as ge,g as z,n as Te,bq as $e,bn as Re,bu as B,bH as Pe,bI as xe,bv as ke,b0 as Ce,bs as me,bJ as Me,by as Ge}from"./DR9_mXdV.js";import{c as K,d as Ie}from"./DiLAK10b.js";function Ve(p,n){if(!p.length)return[];try{const t=p.reduce((x,a)=>a.length>x?a.length:x,0),g=p.map((x,a)=>{if(x.length===t)return x;const r=Object.assign([],x);for(let u=r.length;u<t;u++)r[u]=null;return r}).map((x,a)=>x.map((r,u)=>r==null?{id:"",label:"",data:{},value:null}:typeof r=="number"?{id:"",label:"",data:{},value:r}:{id:r.id??"",label:r.label??"",data:r.data??{},value:r.value}));return De(n.seriesDirection,g)}catch{return[]}}const Ne=p=>{const{data:n=[],dataFormatter:t,chartParams:l}=p;if(!n.length)return[];let g;try{const e=Ve(n,t),x=he({transposedDataGrid:e,dataFormatterGrid:t,chartType:"grid"}),a=Ae({transposedDataGrid:e,dataFormatterGrid:t,chartType:"grid"});let r=0;g=e.map((u,b)=>u.map((m,o)=>{const h=Se("grid",0,b,o),d=a[o],S={id:m.id?m.id:h,index:r,label:m.label?m.label:h,description:m.description??"",data:m.data,value:m.value,gridIndex:0,seriesIndex:b,seriesLabel:x[b],groupIndex:o,groupLabel:d,color:ve(b,l),visible:!0};return S.visible=t.visibleFilter(S,p),r++,S}))}catch(e){throw Error(e)}return g},_e=({computedData$:p,fullDataFormatter$:n,layout$:t})=>{function l(e,x,a){const r=x.groupAxis.position==="top"||x.groupAxis.position==="bottom"?a.width:a.height,u=e[0]?e[0].length-1:0;return K({maxValue:u,minValue:0,axisWidth:r,scaleDomain:[0,u],scaleRange:[0,1]})}function g(e,x,a){const r=x.valueAxis.position==="left"||x.valueAxis.position==="right"?a.height:a.width,u=e.flat();let[b,m]=Le(u);return b===m&&m===0&&(m=1),K({maxValue:m,minValue:b,axisWidth:r,scaleDomain:["auto","auto"],scaleRange:[0,1]})}return E({computedData:p,fullDataFormatter:n,layout:t}).pipe(H(async e=>e),W(e=>{const x=l(e.computedData,e.fullDataFormatter,e.layout),a=g(e.computedData,e.fullDataFormatter,e.layout),r=a(0);return e.computedData.map((u,b)=>u.map((m,o)=>{const h=x(o),d=a(m.value??0);return{...m,axisX:h,axisY:d,axisYFromZero:d-r}}))}))},we=({fullDataFormatter$:p,layout$:n})=>{const t=new te;function l({xAxisPosition:x,yAxisPosition:a,width:r,height:u}){return(x==="bottom"||x==="top")&&(a==="left"||a==="right")?{width:r,height:u}:(x==="left"||x==="right")&&(a==="bottom"||a==="top")?{width:u,height:r}:{width:r,height:u}}const g=p.pipe(W(x=>x.groupAxis.position),ee()),e=p.pipe(W(x=>x.valueAxis.position),ee());return new ie(x=>{E({groupAxisPosition:g,valueAxisPosition:e,layout:n}).pipe(re(t),H(async a=>a)).subscribe(a=>{const r=l({xAxisPosition:a.groupAxisPosition,yAxisPosition:a.valueAxisPosition,width:a.layout.width,height:a.layout.height});return x.next(r),function(){t.next(void 0)}})})},et=({fullDataFormatter$:p,containerSize$:n})=>we({fullDataFormatter$:p,layout$:n}),tt=({computedData$:p})=>p.pipe(W(n=>n.filter(t=>t.length).map(t=>t[0].seriesLabel)),ee((n,t)=>JSON.stringify(n)===JSON.stringify(t))),it=({computedData$:p})=>p.pipe(W(n=>n.map(l=>l.filter(g=>g.visible==!0)).filter(l=>l.length))),rt=({computedAxesData$:p})=>p.pipe(W(n=>n.map(l=>l.filter(g=>g.visible==!0)).filter(l=>l.length))),ot=({computedData$:p,fullDataFormatter$:n,layout$:t})=>E({computedData:p,fullDataFormatter:n,layout:t}).pipe(H(async g=>g),W(g=>{if(g.computedData.length===0)return[{slotIndex:0,rowIndex:0,columnIndex:0,translate:[0,0],scale:[1,1]}];if(g.fullDataFormatter.separateSeries)return ce(g.layout,g.fullDataFormatter.container,g.computedData.length);{const e=ce(g.layout,g.fullDataFormatter.container,1);return g.computedData.map((x,a)=>e[0])}})),st=({isSeriesSeprate$:p,computedData$:n})=>{const t=n.pipe(W(l=>{const g=new Array(l[0]?l[0].length:0).fill(null).map((x,a)=>l.reduce((r,u)=>{if(u&&u[a]){const b=u[a].value==null||u[a].visible==!1?0:u[a].value;return r+b}return r},0));return l.map((x,a)=>x.map((r,u)=>({...r,value:g[u]})))}));return p.pipe(H(l=>ye(()=>l,n,t)))},nt=({computedData$:p,fullDataFormatter$:n})=>E({computedData:p,fullDataFormatter:n}).pipe(H(async t=>t),W(t=>{const l=t.fullDataFormatter.groupAxis,g=t.computedData[0]?t.computedData[0].length-1:0,e=l.scaleDomain[0]-l.scalePadding,x=l.scaleDomain[1]==="max"?g+l.scalePadding:l.scaleDomain[1]+l.scalePadding;return[e,x]})),at=({computedData$:p,groupScaleDomainValue$:n})=>E({computedData:p,groupScaleDomainValue:n}).pipe(W(t=>{const l=t.computedData.map((e,x)=>e.filter((a,r)=>r>=t.groupScaleDomainValue[0]&&r<=t.groupScaleDomainValue[1]&&a.visible==!0));return ue(l)})),lt=({fullDataFormatter$:p,layout$:n})=>{const t=new te;function l({xAxis:g,yAxis:e,width:x,height:a}){if(!g||!e)return{translate:[0,0],scale:[1,1],rotate:0,rotateX:0,rotateY:0,value:""};let r=0,u=0,b=0,m=0,o=0;return g.position==="bottom"?e.position==="left"?(m=180,u=a):e.position==="right"?(m=180,o=180,r=x,u=a):(m=180,u=a):g.position==="top"?e.position==="left"||(e.position==="right"?(o=180,r=x):(m=180,u=a)):g.position==="left"?e.position==="bottom"?(b=-90,u=a):e.position==="top"?(b=-90,o=180):(m=180,u=a):g.position==="right"?e.position==="bottom"?(b=-90,m=180,u=a,r=x):e.position==="top"?(b=-90,m=180,o=180,r=x):(m=180,u=a):(m=180,u=a),{translate:[r,u],scale:[1,1],rotate:b,rotateX:m,rotateY:o,value:`translate(${r}px, ${u}px) rotate(${b}deg) rotateX(${m}deg) rotateY(${o}deg)`}}return new ie(g=>(E({fullDataFormatter:p,layout:n}).pipe(re(t),H(async e=>e)).subscribe(e=>{const x=l({xAxis:e.fullDataFormatter.groupAxis,yAxis:e.fullDataFormatter.valueAxis,width:e.layout.width,height:e.layout.height});g.next(x)}),function(){t.next(void 0)}))},ct=({gridAxesTransform$:p})=>p.pipe(W(n=>{const t=[0,0],l=[1/n.scale[0],1/n.scale[1]],g=n.rotate*-1,e=n.rotateX*-1,x=n.rotateY*-1;return{translate:t,scale:l,rotate:g,rotateX:e,rotateY:x,value:`translate(${t[0]}px, ${t[1]}px) rotateX(${e}deg) rotateY(${x}deg) rotate(${g}deg)`}})),pt=({computedData$:p,groupScaleDomainValue$:n,filteredMinMaxValue$:t,fullDataFormatter$:l,layout$:g})=>{const e=new te;function x({data:a,groupAxis:r,valueAxis:u,groupScaleDomainValue:b,filteredMinMaxValue:m,width:o,height:h}){let d=0,S=0,s=0,D=0;const A=r.position==="top"||r.position==="bottom"?o:h,y=0,R=a[0]?a[0].length-1:0,w=K({maxValue:R,minValue:y,axisWidth:A,scaleDomain:b,scaleRange:[0,1]}),V=w(y),f=w(R);y==R?(d=0,s=1):(d=V,s=(f-V)/A);const M=m[0];let G=m[1];M===G&&G===0&&(G=1);const Y=u.position==="left"||u.position==="right"?h:o,i=K({maxValue:G,minValue:M,axisWidth:Y,scaleDomain:u.scaleDomain,scaleRange:u.scaleRange}),C=ue(a);C[0],C[1];const I=i(C[0]>0?0:C[0]),O=i(C[1]<0?0:C[1]);return S=I,D=(O-I)/Y,{translate:[d,S],scale:[s,D],rotate:0,rotateX:0,rotateY:0,value:`translate(${d}px, ${S}px) scale(${s}, ${D})`}}return new ie(a=>(E({computedData:p,groupScaleDomainValue:n,filteredMinMaxValue:t,fullDataFormatter:l,layout:g}).pipe(re(e),H(async r=>r)).subscribe(r=>{const u=x({data:r.computedData,groupAxis:r.fullDataFormatter.groupAxis,valueAxis:r.fullDataFormatter.valueAxis,groupScaleDomainValue:r.groupScaleDomainValue,filteredMinMaxValue:r.filteredMinMaxValue,width:r.layout.width,height:r.layout.height});a.next(u)}),function(){e.next(void 0)}))},ut=({gridContainerPosition$:p,gridAxesTransform$:n,gridGraphicTransform$:t})=>E({gridContainerPosition:p,gridAxesTransform:n,gridGraphicTransform:t}).pipe(H(async l=>l),W(l=>l.gridAxesTransform.rotate==0||l.gridAxesTransform.rotate==180?l.gridContainerPosition.map((g,e)=>[1/l.gridGraphicTransform.scale[0]/l.gridContainerPosition[e].scale[0],1/l.gridGraphicTransform.scale[1]/l.gridContainerPosition[e].scale[1]]):l.gridContainerPosition.map((g,e)=>[1/l.gridGraphicTransform.scale[0]/l.gridContainerPosition[e].scale[1],1/l.gridGraphicTransform.scale[1]/l.gridContainerPosition[e].scale[0]]))),Fe=({selection:p,pluginName:n,clipPathID:t,seriesLabels$:l,gridContainerPosition$:g,gridAxesTransform$:e,gridGraphicTransform$:x})=>{const a=z(n,"series"),r=z(n,"axes"),u=z(n,"graphic"),b=l.pipe(v((d,S)=>p.selectAll(`g.${a}`).data(d,s=>s).join(s=>s.append("g").classed(a,!0).each((D,A,y)=>{X(y[A]).selectAll(`g.${r}`).data([A]).join(R=>R.append("g").classed(r,!0).attr("clip-path",`url(#${t})`).each((w,V,f)=>{X(f[V]).selectAll("defs").data([V]).join("defs"),X(f[V]).selectAll("g").data([V]).join("g").classed(u,!0)}),R=>R,R=>R.remove())}),s=>s,s=>s.remove())),j(1));T({seriesSelection:b,gridContainerPosition:g}).pipe($(async d=>d)).subscribe(d=>{d.seriesSelection.transition().attr("transform",(S,s)=>{const D=d.gridContainerPosition[s]??d.gridContainerPosition[0],A=D.translate,y=D.scale;return`translate(${A[0]}, ${A[1]}) scale(${y[0]}, ${y[1]})`})});const m=T({seriesSelection:b,gridAxesTransform:e}).pipe($(async d=>d),v(d=>d.seriesSelection.select(`g.${r}`).style("transform",d.gridAxesTransform.value)),j(1)),o=m.pipe(v(d=>d.select("defs")),j(1)),h=T({axesSelection:m,gridGraphicTransform:x}).pipe($(async d=>d),v(d=>{const S=d.axesSelection.select(`g.${u}`);return S.transition().duration(50).style("transform",d.gridGraphicTransform.value),S}),j(1));return{seriesSelection$:b,axesSelection$:m,defsSelection$:o,graphicGSelection$:h}},ze=({selection:p,pluginName:n,computedData$:t,gridContainerPosition$:l,isSeriesSeprate$:g})=>{const e=z(n,"container"),x=T({computedData:t.pipe(F((a,r)=>a.length===r.length)),isSeriesSeprate:g}).pipe($(async a=>a),v(a=>a.isSeriesSeprate?a.computedData:[a.computedData[0]]),v((a,r)=>p.selectAll(`g.${e}`).data(a,u=>u&&u[0]?u[0].seriesIndex:r).join("g").classed(e,!0)),j(1));return T({containerSelection:x,gridContainerPosition:l}).pipe($(async a=>a)).subscribe(a=>{a.containerSelection.attr("transform",(r,u)=>{const b=a.gridContainerPosition[u]??a.gridContainerPosition[0],m=b.translate,o=b.scale;return`translate(${m[0]}, ${m[1]}) scale(${o[0]}, ${o[1]})`})}),x},gt=({fullDataFormatter$:p,gridAxesSize$:n,computedData$:t,fullChartParams$:l,gridContainerPosition$:g,layout$:e})=>{const x=new Q,a=T({fullDataFormatter:p,gridAxesSize:n,computedData:t}).pipe($(async o=>o),v(o=>{const h=o.computedData[0]?o.computedData[0].length-1:0,d=o.fullDataFormatter.groupAxis.scaleDomain[0]-o.fullDataFormatter.groupAxis.scalePadding,S=o.fullDataFormatter.groupAxis.scaleDomain[1]==="max"?h+o.fullDataFormatter.groupAxis.scalePadding:o.fullDataFormatter.groupAxis.scaleDomain[1]+o.fullDataFormatter.groupAxis.scalePadding;return[d,S]}),j(1)),r=T({fullDataFormatter:p,computedData:t}).pipe($(async o=>o),v(o=>o.fullDataFormatter.seriesDirection==="row"?(o.computedData[0]??[]).map(h=>h.groupLabel):o.computedData.map(h=>h[0].groupLabel))),u=T({groupScaleDomain:a,groupLabels:r}).pipe($(async o=>o),v(o=>o.groupLabels.filter((h,d)=>d>=o.groupScaleDomain[0]&&d<=o.groupScaleDomain[1]))),b=g.pipe(v(o=>o.reduce((d,S)=>S.columnIndex>d?S.columnIndex:d,0)+1),F()),m=g.pipe(v(o=>o.reduce((d,S)=>S.rowIndex>d?S.rowIndex:d,0)+1),F());return new q(o=>{T({dataFormatter:p,axisSize:n,fullChartParams:l,scaleRangeGroupLabels:u,groupLabels:r,groupScaleDomain:a,columnAmount:b,rowAmount:m,layout:e}).pipe(k(x),$(async h=>h)).subscribe(h=>{const d=h.dataFormatter.valueAxis.position==="right"||h.dataFormatter.valueAxis.position==="bottom",S=ge({axisLabels:h.scaleRangeGroupLabels,axisWidth:h.axisSize.width,padding:h.dataFormatter.groupAxis.scalePadding,reverse:d}),s=A=>h.dataFormatter.groupAxis.position==="bottom"||h.dataFormatter.groupAxis.position==="top"?A.offsetX-h.fullChartParams.padding.left:A.offsetY-h.fullChartParams.padding.top,D=A=>{const y={offsetX:A.offsetX*h.columnAmount%h.layout.rootWidth,offsetY:A.offsetY*h.rowAmount%h.layout.rootHeight},R=s(y),w=S(R),V=Math.ceil(h.groupScaleDomain[0]),f=w+V;return{groupIndex:f,groupLabel:h.groupLabels[f]??""}};return o.next(D),function(){x.next(void 0)}})})},xt=({rootSelection:p,fullDataFormatter$:n,containerSize$:t,gridAxesContainerSize$:l,computedData$:g,gridContainerPosition$:e,layout$:x})=>{const a=Ie(p,"mousemove"),r=T({fullDataFormatter:n,computedData:g}).pipe($(async s=>s),v(s=>{const D=s.computedData[0]?s.computedData[0].length-1:0,A=s.fullDataFormatter.groupAxis.scaleDomain[0]-s.fullDataFormatter.groupAxis.scalePadding,y=s.fullDataFormatter.groupAxis.scaleDomain[1]==="max"?D+s.fullDataFormatter.groupAxis.scalePadding:s.fullDataFormatter.groupAxis.scaleDomain[1]+s.fullDataFormatter.groupAxis.scalePadding;return[A,y]}),j(1)),u=T({fullDataFormatter:n,computedData:g}).pipe($(async s=>s),v(s=>s.fullDataFormatter.seriesDirection==="row"?(s.computedData[0]??[]).map(D=>D.groupLabel):s.computedData.map(D=>D[0].groupLabel))),b=T({groupScaleDomain:r,groupLabels:u}).pipe($(async s=>s),v(s=>s.groupLabels.filter((D,A)=>A>=s.groupScaleDomain[0]&&A<=s.groupScaleDomain[1]))),m=n.pipe(v(s=>s.valueAxis.position==="right"||s.valueAxis.position==="bottom")),o=T({reverse:m,gridAxesContainerSize:l,scaleRangeGroupLabels:b,fullDataFormatter:n}).pipe($(async s=>s),v(s=>ge({axisLabels:s.scaleRangeGroupLabels,axisWidth:s.gridAxesContainerSize.width,padding:s.fullDataFormatter.groupAxis.scalePadding,reverse:s.reverse}))),h=T({fullDataFormatter:n,rootMousemove:a,gridContainerPosition:e,layout:x}).pipe($(async s=>s),v(s=>{if(s.fullDataFormatter.groupAxis.position==="bottom"||s.fullDataFormatter.groupAxis.position==="top"){let D=s.rootMousemove.offsetX;const y=s.gridContainerPosition.map((R,w)=>{var V;return[R.translate[0],((V=s.gridContainerPosition[w+1])==null?void 0:V.translate[0])??s.layout.rootWidth]}).filter(R=>R[0]<R[1]).find(R=>D>=R[0]&&D<=R[1]);return y&&(D=D-y[0]),D-s.layout.left}else{let D=s.rootMousemove.offsetY;const y=s.gridContainerPosition.map((R,w)=>{var V;return[R.translate[1],((V=s.gridContainerPosition[w+1])==null?void 0:V.translate[1])??s.layout.rootHeight]}).filter(R=>R[0]<R[1]).find(R=>D>=R[0]&&D<=R[1]);return y&&(D=D-y[0]),D-s.layout.top}})),d=T({xIndexScale:o,axisValue:h,groupScaleDomain:r}).pipe($(async s=>s),v(s=>{const D=s.xIndexScale(s.axisValue),A=Math.ceil(s.groupScaleDomain[0]);return D+A})),S=T({groupIndex:d,groupLabels:u}).pipe($(async s=>s),v(s=>s.groupLabels[s.groupIndex]??""));return T({groupIndex:d,groupLabel:S}).pipe($(async s=>s),v(s=>({groupIndex:s.groupIndex,groupLabel:s.groupLabel})))},fe=.3;function pe({axisWidth:p,groupAmount:n,barAmountOfGroup:t,barPadding:l=0,barGroupPadding:g=0}){const x=((n>1?p/(n-1):p)-g)/t-l;return x>1?x:1}function We(p,n,t){const l=p/2,g=p*n.length+t.barPadding*n.length;return $e().domain(n).range([-g/2+l,g/2-l])}function Ye(p,n){return p<=1?0:n/(p-1)*fe}function Oe(p,n){return p<=1?n:n*(1-fe)}function Xe({graphicGSelection:p,rectClassName:n,visibleComputedAxesData:t,zeroYArr:l,groupLabels:g,barScale:e,params:x,chartParams:a,barWidth:r,transformedBarRadius:u,delayGroup:b,transitionItem:m,isSeriesSeprate:o}){const h=r/2;return p.each((S,s,D)=>{X(D[s]).selectAll(`rect.${n}`).data(t[s]??[],A=>A.id).join(A=>A.append("rect").classed(n,!0).attr("cursor","pointer").attr("height",y=>1),A=>A,A=>A.remove()).attr("transform",(A,y)=>`translate(${(A?A.axisX:0)-h}, 0)`).attr("fill",A=>A.color).attr("y",A=>A.axisY<l[s]?A.axisY:l[s]).attr("x",A=>o?0:e(A.seriesLabel)).attr("width",r).attr("rx",u[s][0]??1).attr("ry",u[s][1]??1).transition().duration(m).ease(Re(a.transitionEase)).delay((A,y)=>A.groupIndex*b).attr("height",A=>Math.abs(A.axisYFromZero)||1)}),p.selectAll(`rect.${n}`)}function je({defsSelection:p,clipPathData:n}){p.selectAll("clipPath").data(n).join(t=>t.append("clipPath"),t=>t,t=>t.remove()).attr("id",t=>t.id).each((t,l,g)=>{X(g[l]).selectAll("rect").data([t]).join(e=>e.append("rect"),e=>e,e=>e.remove()).attr("x",0).attr("y",0).attr("width",e=>e.width).attr("height",e=>e.height)})}function Be({selection:p,ids:n,fullChartParams:t}){if(p.interrupt("highlight"),!n.length){p.transition("highlight").duration(200).style("opacity",1);return}p.each((l,g,e)=>{n.includes(l.id)?X(e[g]).style("opacity",1):X(e[g]).style("opacity",t.styles.unhighlightedOpacity)})}const mt=(p,{selection:n,computedData$:t,computedAxesData$:l,visibleComputedData$:g,visibleComputedAxesData$:e,seriesLabels$:x,SeriesDataMap$:a,GroupDataMap$:r,fullParams$:u,fullChartParams$:b,gridAxesTransform$:m,gridGraphicTransform$:o,gridGraphicReverseScale$:h,gridAxesSize$:d,gridHighlight$:S,gridContainerPosition$:s,isSeriesSeprate$:D,event$:A})=>{const y=new Q,R=Te(p,"clipPath-box"),w=z(p,"rect"),{seriesSelection$:V,axesSelection$:f,defsSelection$:M,graphicGSelection$:G}=Fe({selection:n,pluginName:p,clipPathID:R,seriesLabels$:x,gridContainerPosition$:s,gridAxesTransform$:m,gridGraphicTransform$:o}),Y=e.pipe(k(y),v(c=>c.map(P=>P[0]?P[0].axisY-P[0].axisYFromZero:0)),F()),i=T({computedData:t,visibleComputedData:g,params:u,gridAxesSize:d,isSeriesSeprate:D}).pipe(k(y),$(async c=>c),v(c=>c.params.barWidth?c.params.barWidth:c.isSeriesSeprate?pe({axisWidth:c.gridAxesSize.width,groupAmount:c.computedData[0]?c.computedData[0].length:0,barAmountOfGroup:1,barPadding:c.params.barPadding,barGroupPadding:c.params.barGroupPadding}):pe({axisWidth:c.gridAxesSize.width,groupAmount:c.computedData[0]?c.computedData[0].length:0,barAmountOfGroup:c.visibleComputedData.length,barPadding:c.params.barPadding,barGroupPadding:c.params.barGroupPadding})),F()),C=T({computedData:t,barWidth:i,params:u,gridGraphicReverseScale:h}).pipe(k(y),$(async c=>c),v(c=>{const P=c.barWidth/2,L=c.params.barRadius===!0?P:c.params.barRadius===!1?0:typeof c.params.barRadius=="number"?c.params.barRadius:0;return c.computedData.map((ne,be)=>{const ae=c.gridGraphicReverseScale[be]??c.gridGraphicReverseScale[0];let Z=L*ae[0],N=L*ae[1];if(Z>P){const le=P/Z;Z=Z*le,N=N*le}return[Z,N]})})),I=g.pipe(k(y),v(c=>{const P=new Set;return c.forEach(L=>{L.forEach(ne=>{P.add(ne.groupLabel)})}),Array.from(P)})),O=T({seriesLabels:x,barWidth:i,params:u}).pipe(k(y),$(async c=>c),v(c=>We(c.barWidth,c.seriesLabels,c.params))),U=b.pipe(k(y),v(c=>c.transitionDuration),F()),J=new q(c=>{T({groupLabels:I,transitionDuration:U}).pipe($(async P=>P)).subscribe(P=>{const L=Ye(P.groupLabels.length,P.transitionDuration);c.next(L)})}).pipe(k(y),F()),de=new q(c=>{T({groupLabels:I,transitionDuration:U}).pipe($(async P=>P)).subscribe(P=>{const L=Oe(P.groupLabels.length,P.transitionDuration);c.next(L)})}).pipe(k(y),F());T({defsSelection:M,gridAxesSize:d}).pipe(k(y),$(async c=>c)).subscribe(c=>{const P=[{id:R,width:c.gridAxesSize.width,height:c.gridAxesSize.height}];je({defsSelection:c.defsSelection,clipPathData:P})});const oe=b.pipe(k(y),v(c=>c.highlightTarget),F()),se=T({graphicGSelection:G,visibleComputedAxesData:e,zeroYArr:Y,groupLabels:I,barScale:O,params:u,chartParams:b,highlightTarget:oe,barWidth:i,transformedBarRadius:C,delayGroup:J,transitionItem:de,isSeriesSeprate:D}).pipe(k(y),$(async c=>c),v(c=>Xe({graphicGSelection:c.graphicGSelection,rectClassName:w,visibleComputedAxesData:c.visibleComputedAxesData,zeroYArr:c.zeroYArr,groupLabels:c.groupLabels,barScale:c.barScale,params:c.params,chartParams:c.chartParams,barWidth:c.barWidth,transformedBarRadius:c.transformedBarRadius,delayGroup:c.delayGroup,transitionItem:c.transitionItem,isSeriesSeprate:c.isSeriesSeprate})));return T({barSelection:se,computedData:t,highlightTarget:oe,SeriesDataMap:a,GroupDataMap:r}).pipe(k(y),$(async c=>c)).subscribe(c=>{c.barSelection.on("mouseover",(P,L)=>{P.stopPropagation(),A.next({type:"grid",eventName:"mouseover",pluginName:p,highlightTarget:c.highlightTarget,datum:L,gridIndex:L.gridIndex,series:c.SeriesDataMap.get(L.seriesLabel),seriesIndex:L.seriesIndex,seriesLabel:L.seriesLabel,group:c.GroupDataMap.get(L.groupLabel),groupIndex:L.groupIndex,groupLabel:L.groupLabel,event:P,data:c.computedData})}).on("mousemove",(P,L)=>{P.stopPropagation(),A.next({type:"grid",eventName:"mousemove",pluginName:p,highlightTarget:c.highlightTarget,datum:L,gridIndex:L.gridIndex,series:c.SeriesDataMap.get(L.seriesLabel),seriesIndex:L.seriesIndex,seriesLabel:L.seriesLabel,group:c.GroupDataMap.get(L.groupLabel),groupIndex:L.groupIndex,groupLabel:L.groupLabel,event:P,data:c.computedData})}).on("mouseout",(P,L)=>{P.stopPropagation(),A.next({type:"grid",eventName:"mouseout",pluginName:p,highlightTarget:c.highlightTarget,datum:L,gridIndex:L.gridIndex,series:c.SeriesDataMap.get(L.seriesLabel),seriesIndex:L.seriesIndex,seriesLabel:L.seriesLabel,group:c.GroupDataMap.get(L.groupLabel),groupIndex:L.groupIndex,groupLabel:L.groupLabel,event:P,data:c.computedData})}).on("click",(P,L)=>{P.stopPropagation(),A.next({type:"grid",eventName:"click",pluginName:p,highlightTarget:c.highlightTarget,datum:L,gridIndex:L.gridIndex,series:c.SeriesDataMap.get(L.seriesLabel),seriesIndex:L.seriesIndex,seriesLabel:L.seriesLabel,group:c.GroupDataMap.get(L.groupLabel),groupIndex:L.groupIndex,groupLabel:L.groupLabel,event:P,data:c.computedData})})}),T({barSelection:se,highlight:S.pipe(v(c=>c.map(P=>P.id))),fullChartParams:b}).pipe(k(y),$(async c=>c)).subscribe(c=>{Be({selection:c.barSelection,ids:c.highlight,fullChartParams:c.fullChartParams})}),()=>{y.next(void 0)}},_=6;function Ee(p,n){return p.map((t,l)=>{const g=me(t,n),e=typeof g=="string"?g.split(`
`):[g];return{text:g,textArr:e}})}function He({selection:p,groupingLabelClassName:n,fullParams:t,axisLabelAlign:l,gridAxesSize:g,fullDataFormatter:e,chartParams:x,textReverseTransform:a}){const r=t.tickPadding+t.labelOffset[0],u=t.tickPadding+t.labelOffset[1];let b=0,m=0;e.groupAxis.position==="bottom"?(m=u,e.valueAxis.position==="left"?b=r:e.valueAxis.position==="right"&&(b=-r)):e.groupAxis.position==="top"?(m=-u,e.valueAxis.position==="left"?b=r:e.valueAxis.position==="right"&&(b=-r)):e.groupAxis.position==="left"?(b=-r,e.valueAxis.position==="bottom"?m=-u:e.valueAxis.position==="top"&&(m=u)):e.groupAxis.position==="right"&&(b=r,e.valueAxis.position==="bottom"?m=-u:e.valueAxis.position==="top"&&(m=u)),p.selectAll(`g.${n}`).data([t]).join("g").classed(n,!0).each((o,h,d)=>{X(d[h]).selectAll("text").data([o]).join(S=>S.append("text").style("font-weight","bold"),S=>S,S=>S.remove()).attr("text-anchor",l.textAnchor).attr("dominant-baseline",l.dominantBaseline).attr("font-size",x.styles.textSize).style("fill",B(t.labelColorType,x)).style("transform",a).attr("x",b).attr("y",m).text(S=>e.groupAxis.label)}).attr("transform",o=>`translate(${g.width}, 0)`)}function Ue({selection:p,xAxisClassName:n,fullParams:t,tickTextAlign:l,gridAxesSize:g,fullDataFormatter:e,chartParams:x,groupScale:a,groupScaleDomain:r,groupLabelData:u,textReverseTransformWithRotate:b,textSizePx:m}){const o=p.selectAll(`g.${n}`).data([t]).join("g").classed(n,!0),h=Math.floor(r[1])-Math.ceil(r[0])+1;let d=0,S=0;e.groupAxis.position==="left"?(d=0,S=-t.tickPadding):e.groupAxis.position==="right"?(d=0,S=t.tickPadding):e.groupAxis.position==="bottom"?(t.tickFullLine==!0?d=-t.tickPadding:d=-t.tickPadding-_,S=0):e.groupAxis.position==="top"&&(t.tickFullLine==!0?d=t.tickPadding:d=t.tickPadding-_,S=-0);const s=Pe(a).scale(a).ticks(t.ticks==="all"||t.ticks>h?h:t.ticks).tickSize(t.tickFullLine==!0?-g.height:_).tickSizeOuter(0).tickFormat(y=>{var R;return((R=u[y])==null?void 0:R.text)??""}).tickPadding(d),D=o.transition().duration(100).ease(xe).call(s).on("end",(y,R)=>{o.selectAll(".tick text").each((w,V,f)=>{var G;const M=((G=u[w])==null?void 0:G.textArr)??[];ke(X(f[V]),{textArr:M,textSizePx:m,groupAxisPosition:e.groupAxis.position,isContainerRotated:!0})})});return D.selectAll("line").style("fill","none").style("stroke",t.tickLineVisible==!0?B(t.tickColorType,x):"none").style("stroke-dasharray",t.tickFullLineDasharray).style("vector-effect","non-scaling-stroke").attr("pointer-events","none"),D.selectAll("path").style("fill","none").style("stroke",t.axisLineVisible==!0?B(t.axisLineColorType,x):"none").style("shape-rendering","crispEdges"),o.selectAll("text").attr("font-size",x.styles.textSize).attr("fill",B(t.tickTextColorType,x)).attr("text-anchor",l.textAnchor).attr("dominant-baseline",l.dominantBaseline).attr("x",S).style("transform",b).attr("dy",0),o}const ft=(p,{selection:n,computedData$:t,fullParams$:l,fullDataFormatter$:g,fullChartParams$:e,gridAxesTransform$:x,gridAxesReverseTransform$:a,gridAxesSize$:r,gridContainerPosition$:u,isSeriesSeprate$:b,textSizePx$:m})=>{const o=new Q,h=z(p,"container"),d=z(p,"xAxisG"),S=z(p,"xAxis"),s=z(p,"groupingLabel"),D=T({computedData:t.pipe(F((i,C)=>i.length===C.length)),isSeriesSeprate:b}).pipe(k(o),$(async i=>i),v(i=>i.isSeriesSeprate?i.computedData:[i.computedData[0]]),v((i,C)=>n.selectAll(`g.${h}`).data(i,I=>I&&I[0]?I[0].seriesIndex:C).join("g").classed(h,!0))),A=D.pipe(k(o),v((i,C)=>i.selectAll(`g.${d}`).data([d]).join("g").classed(d,!0)));T({containerSelection:D,gridContainerPosition:u}).pipe(k(o),$(async i=>i)).subscribe(i=>{i.containerSelection.attr("transform",(C,I)=>{const O=i.gridContainerPosition[I]??i.gridContainerPosition[0],U=O.translate,J=O.scale;return`translate(${U[0]}, ${U[1]}) scale(${J[0]}, ${J[1]})`})}),T({axisSelection:A,gridAxesTransform:x}).pipe(k(o),$(async i=>i)).subscribe(i=>{i.axisSelection.style("transform",i.gridAxesTransform.value)});const y=T({gridAxesReverseTransform:a,gridContainerPosition:u}).pipe(k(o),$(async i=>i),v(i=>{const C=`rotateX(${i.gridAxesReverseTransform.rotateX}deg) rotateY(${i.gridAxesReverseTransform.rotateY}deg)`,I=`rotate(${i.gridAxesReverseTransform.rotate}deg)`,O=`scale(${1/i.gridContainerPosition[0].scale[0]}, ${1/i.gridContainerPosition[0].scale[1]})`;return`${C} ${I} ${O}`}),F()),R=T({textReverseTransform:y,fullParams:l}).pipe(k(o),$(async i=>i),v(i=>`${i.textReverseTransform} rotate(${i.fullParams.tickTextRotate}deg)`)),w=T({fullDataFormatter:g,gridAxesSize:r,computedData:t}).pipe(k(o),$(async i=>i),v(i=>{const C=i.computedData[0]?i.computedData[0].length-1:0,I=i.fullDataFormatter.groupAxis.scaleDomain[0]-i.fullDataFormatter.groupAxis.scalePadding,O=i.fullDataFormatter.groupAxis.scaleDomain[1]==="max"?C+i.fullDataFormatter.groupAxis.scalePadding:i.fullDataFormatter.groupAxis.scaleDomain[1]+i.fullDataFormatter.groupAxis.scalePadding;return[I,O]}),j(1)),V=T({groupScaleDomain:w,gridAxesSize:r}).pipe(k(o),$(async i=>i),v(i=>Ce().domain(i.groupScaleDomain).range([0,i.gridAxesSize.width]))),f=t.pipe(v(i=>(i[0]??[]).map(C=>C.groupLabel))),M=T({fullDataFormatter:g,fullParams:l}).pipe(k(o),$(async i=>i),v(i=>{let C="middle",I="hanging";return i.fullDataFormatter.groupAxis.position==="bottom"?(C=i.fullParams.tickTextRotate?"end":"middle",I="hanging"):i.fullDataFormatter.groupAxis.position==="top"?(C=i.fullParams.tickTextRotate?"start":"middle",I="auto"):i.fullDataFormatter.groupAxis.position==="left"?(C="end",I="middle"):i.fullDataFormatter.groupAxis.position==="right"&&(C="start",I="middle"),{textAnchor:C,dominantBaseline:I}})),G=g.pipe(k(o),v(i=>{let C="start",I="hanging";return i.groupAxis.position==="bottom"?I="hanging":i.groupAxis.position==="top"?I="auto":i.groupAxis.position==="left"?C="end":i.groupAxis.position==="right"&&(C="start"),i.valueAxis.position==="left"?C="start":i.valueAxis.position==="right"?C="end":i.valueAxis.position==="bottom"?I="auto":i.valueAxis.position==="top"&&(I="hanging"),{textAnchor:C,dominantBaseline:I}})),Y=T({groupLabels:f,fullParams:l}).pipe(k(o),$(async i=>i),v(i=>Ee(i.groupLabels,i.fullParams.tickFormat)));return T({axisSelection:A,fullParams:l,tickTextAlign:M,axisLabelAlign:G,gridAxesSize:r,fullDataFormatter:g,chartParams:e,groupScale:V,groupScaleDomain:w,groupLabelData:Y,textReverseTransform:y,textReverseTransformWithRotate:R,textSizePx:m}).pipe(k(o),$(async i=>i)).subscribe(i=>{Ue({selection:i.axisSelection,xAxisClassName:S,fullParams:i.fullParams,tickTextAlign:i.tickTextAlign,gridAxesSize:i.gridAxesSize,fullDataFormatter:i.fullDataFormatter,chartParams:i.chartParams,groupScale:i.groupScale,groupScaleDomain:i.groupScaleDomain,groupLabelData:i.groupLabelData,textReverseTransformWithRotate:i.textReverseTransformWithRotate,textSizePx:i.textSizePx}),He({selection:i.axisSelection,groupingLabelClassName:s,fullParams:i.fullParams,axisLabelAlign:i.axisLabelAlign,gridAxesSize:i.gridAxesSize,fullDataFormatter:i.fullDataFormatter,chartParams:i.chartParams,textReverseTransform:i.textReverseTransform})}),()=>{o.next(void 0)}},Je=6;function Ze({selection:p,textClassName:n,fullParams:t,axisLabelAlign:l,gridAxesSize:g,fullDataFormatter:e,fullChartParams:x,textReverseTransform:a}){const r=t.tickPadding-t.labelOffset[0],u=t.tickPadding+t.labelOffset[1];let b=0,m=0;e.groupAxis.position==="bottom"?(m=-u,e.valueAxis.position==="left"?b=-r:e.valueAxis.position==="right"&&(b=r)):e.groupAxis.position==="top"?(m=u,e.valueAxis.position==="left"?b=-r:e.valueAxis.position==="right"&&(b=r)):e.groupAxis.position==="left"?(b=r,e.valueAxis.position==="bottom"?m=u:e.valueAxis.position==="top"&&(m=-u)):e.groupAxis.position==="right"&&(b=-r,e.valueAxis.position==="bottom"?m=u:e.valueAxis.position==="top"&&(m=-u)),p.selectAll(`g.${n}`).data([t]).join("g").classed(n,!0).each((o,h,d)=>{X(d[h]).selectAll("text").data([o]).join(S=>S.append("text").style("font-weight","bold"),S=>S,S=>S.remove()).attr("text-anchor",l.textAnchor).attr("dominant-baseline",l.dominantBaseline).attr("font-size",x.styles.textSize).style("fill",B(t.labelColorType,x)).style("transform",a).attr("x",b).attr("y",m).text(S=>e.valueAxis.label)}).attr("transform",o=>`translate(0, ${g.height})`)}function qe({selection:p,yAxisClassName:n,fullParams:t,tickTextAlign:l,gridAxesSize:g,fullDataFormatter:e,fullChartParams:x,valueScale:a,textReverseTransformWithRotate:r,filteredMinMaxValue:u}){const b=p.selectAll(`g.${n}`).data([t]).join("g").classed(n,!0);let m=0,o=0;e.valueAxis.position==="left"?(m=t.tickPadding,o=0):e.valueAxis.position==="right"?(m=-t.tickPadding,o=0):e.valueAxis.position==="bottom"?(m=0,o=t.tickPadding):e.valueAxis.position==="top"&&(m=0,o=-t.tickPadding);const h=Me(a).scale(a).ticks(t.ticks).tickFormat(s=>me(s,t.tickFormat)).tickSize(t.tickFullLine==!0?-g.width:Je).tickPadding(m),d=b.transition().duration(100).ease(xe).call(h);d.selectAll("line").style("fill","none").style("stroke",t.tickLineVisible==!0?B(t.tickColorType,x):"none").style("stroke-dasharray",t.tickFullLineDasharray).style("vector-effect","non-scaling-stroke").attr("pointer-events","none"),d.selectAll("path").style("fill","none").style("stroke",t.axisLineVisible==!0?B(t.axisLineColorType,x):"none").style("shape-rendering","crispEdges");const S=b.selectAll("text").attr("font-size",x.styles.textSize).style("color",B(t.tickTextColorType,x)).attr("text-anchor",l.textAnchor).attr("dominant-baseline",l.dominantBaseline).attr("y",o).attr("dy",0);return S.style("transform",r),(e.valueAxis.position==="bottom"||e.valueAxis.position==="top")&&S.attr("dy",0),b}const dt=(p,{selection:n,computedData$:t,filteredMinMaxValue$:l,fullParams$:g,fullDataFormatter$:e,fullChartParams$:x,gridAxesSize$:a,gridAxesTransform$:r,gridAxesReverseTransform$:u,gridContainerPosition$:b,isSeriesSeprate$:m})=>{const o=new Q,h=z(p,"yAxisG"),d=z(p,"yAxis"),S=z(p,"text"),D=ze({selection:n,pluginName:p,computedData$:t,gridContainerPosition$:b,isSeriesSeprate$:m}).pipe(k(o),v((f,M)=>f.selectAll(`g.${h}`).data([h]).join("g").classed(h,!0)));T({axisSelection:D,gridAxesTransform:r}).pipe(k(o),$(async f=>f)).subscribe(f=>{f.axisSelection.style("transform",f.gridAxesTransform.value)});const A=T({gridAxesReverseTransform:u,gridContainerPosition:b}).pipe(k(o),$(async f=>f),v(f=>{const M=`rotateX(${f.gridAxesReverseTransform.rotateX}deg) rotateY(${f.gridAxesReverseTransform.rotateY}deg)`,G=`rotate(${f.gridAxesReverseTransform.rotate}deg)`,Y=`scale(${1/f.gridContainerPosition[0].scale[0]}, ${1/f.gridContainerPosition[0].scale[1]})`;return`${M} ${G} ${Y}`}),F()),y=T({textReverseTransform:A,fullParams:g}).pipe(k(o),$(async f=>f),v(f=>`${f.textReverseTransform} rotate(${f.fullParams.tickTextRotate}deg)`)),R=new q(f=>{T({fullDataFormatter:e,gridAxesSize:a,filteredMinMaxValue:l}).pipe(k(o),$(async M=>M)).subscribe(M=>{let G=M.filteredMinMaxValue[1],Y=M.filteredMinMaxValue[0];G===Y&&G===0&&(G=1);const i=Ge({maxValue:G,minValue:Y,axisWidth:M.gridAxesSize.height,scaleDomain:M.fullDataFormatter.valueAxis.scaleDomain,scaleRange:M.fullDataFormatter.valueAxis.scaleRange});f.next(i)})}),w=T({fullDataFormatter:e,fullParams:g}).pipe(k(o),$(async f=>f),v(f=>{let M="start",G="hanging";return f.fullDataFormatter.valueAxis.position==="left"?(M="end",G="middle"):f.fullDataFormatter.valueAxis.position==="right"?(M="start",G="middle"):f.fullDataFormatter.valueAxis.position==="bottom"?(M=f.fullParams.tickTextRotate?"end":"middle",G="hanging"):f.fullDataFormatter.valueAxis.position==="top"&&(M=f.fullParams.tickTextRotate?"start":"middle",G="auto"),{textAnchor:M,dominantBaseline:G}})),V=e.pipe(k(o),v(f=>{let M="start",G="hanging";return f.groupAxis.position==="bottom"?G="auto":f.groupAxis.position==="top"?G="hanging":f.groupAxis.position==="left"?M="start":f.groupAxis.position==="right"&&(M="end"),f.valueAxis.position==="left"?M="end":f.valueAxis.position==="right"?M="start":f.valueAxis.position==="bottom"?G="hanging":f.valueAxis.position==="top"&&(G="auto"),{textAnchor:M,dominantBaseline:G}}));return T({axisSelection:D,fullParams:g,tickTextAlign:w,axisLabelAlign:V,computedData:t,gridAxesSize:a,fullDataFormatter:e,fullChartParams:x,valueScale:R,textReverseTransform:A,textReverseTransformWithRotate:y,filteredMinMaxValue:l}).pipe(k(o),$(async f=>f)).subscribe(f=>{qe({selection:f.axisSelection,yAxisClassName:d,fullParams:f.fullParams,tickTextAlign:f.tickTextAlign,gridAxesSize:f.gridAxesSize,fullDataFormatter:f.fullDataFormatter,fullChartParams:f.fullChartParams,valueScale:f.valueScale,textReverseTransformWithRotate:f.textReverseTransformWithRotate,filteredMinMaxValue:f.filteredMinMaxValue}),Ze({selection:f.axisSelection,textClassName:S,fullParams:f.fullParams,axisLabelAlign:f.axisLabelAlign,gridAxesSize:f.gridAxesSize,fullDataFormatter:f.fullDataFormatter,fullChartParams:f.fullChartParams,textReverseTransform:f.textReverseTransform})}),()=>{o.next(void 0)}};export{dt as a,Ve as b,mt as c,et as d,tt as e,it as f,we as g,_e as h,rt as i,st as j,nt as k,at as l,lt as m,ct as n,pt as o,ut as p,ft as q,Fe as r,gt as s,xt as t,ot as u,Ne as v};
