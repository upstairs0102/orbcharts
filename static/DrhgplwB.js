import{aB as l,aT as k,aJ as o,aM as f,aP as z,aU as I,aV as E,aQ as w,aR as U,aW as j,bA as N,B as p,S as m,D as X,L as H,G as Y,i as T,aj as W,E as q,at as J}from"./DR9_mXdV.js";import{u as Q,g as K,d as Z,e as v,h as tt,f as at,i as et,j as rt,k as ot,l as x,m as st,n as it,o as nt,p as lt,v as ut,c as pt,q as mt,a as $t}from"./D_lgk1xP.js";import{c as ct}from"./DzUFsZE_.js";const dt=r=>{const a=l(r,{visibleFilter:{toBeTypes:["Function"]},container:{toBeTypes:["object"]},seriesDirection:{toBe:'"row" | "column"',test:e=>e==="row"||e==="column"},rowLabels:{toBeTypes:["string[]"]},columnLabels:{toBeTypes:["string[]"]},valueAxis:{toBeTypes:["object"]},groupAxis:{toBeTypes:["object"]},separateSeries:{toBeTypes:["boolean"]}});if(a.status==="error")return a;if(r.valueAxis){const e=l(r.valueAxis,{position:{toBe:'"bottom" | "left" | "top" | "right"',test:t=>t==="bottom"||t==="left"||t==="top"||t==="right"},scaleDomain:{toBe:'[number | "min" | "auto", number | "max" | "auto"]',test:t=>Array.isArray(t)&&t.length===2&&(typeof t[0]=="number"||t[0]==="min"||t[0]==="auto")&&(typeof t[1]=="number"||t[1]==="max"||t[1]==="auto")},scaleRange:{toBe:"[number, number]",test:t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="number"&&typeof t[1]=="number"},label:{toBeTypes:["string"]}});if(e.status==="error")return e}if(r.groupAxis){const e=l(r.groupAxis,{position:{toBe:'"bottom" | "left" | "top" | "right"',test:t=>t==="bottom"||t==="left"||t==="top"||t==="right"},scaleDomain:{toBe:'[number, number | "max"]',test:t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="number"&&(typeof t[1]=="number"||t[1]==="max")},scalePadding:{toBeTypes:["number"]},label:{toBeTypes:["string"]}});if(e.status==="error")return e}if(r.container){const e=l(r.container,{columnAmount:{toBeTypes:["number"]},rowAmount:{toBeTypes:["number"]},columnGap:{toBe:'"auto" | number',test:t=>t==="auto"||typeof t=="number"},rowGap:{toBe:'"auto" | number',test:t=>t==="auto"||typeof t=="number"}});if(e.status==="error")return e}return a},ft=r=>l({data:r},{data:{toBe:"(DataGridDatum | DataGridValue)[][]",test:e=>Array.isArray(e)}}),yt=({subject:r,observer:a})=>{const e=k(a.fullChartParams$).pipe(o(1)),t=a.fullDataFormatter$.pipe(f(n=>n.separateSeries),z(),o(1)),s=Q({computedData$:a.computedData$,fullDataFormatter$:a.fullDataFormatter$,layout$:a.layout$}).pipe(o(1)),i=I({layout$:a.layout$,containerPosition$:s,container$:a.fullDataFormatter$.pipe(f(n=>n.container))}).pipe(o(1)),$=K({fullDataFormatter$:a.fullDataFormatter$,layout$:a.layout$}).pipe(o(1)),P=Z({fullDataFormatter$:a.fullDataFormatter$,containerSize$:i}).pipe(o(1)),c=a.computedData$.pipe(f(n=>n.flat())).pipe(o(1)),h=E({datumList$:c,fullChartParams$:a.fullChartParams$,event$:r.event$}).pipe(o(1)),O=v({computedData$:a.computedData$}),F=w({datumList$:c}).pipe(o(1)),R=U({datumList$:c}).pipe(o(1)),y=tt({computedData$:a.computedData$,fullDataFormatter$:a.fullDataFormatter$,layout$:a.layout$}).pipe(o(1)),G=at({computedData$:a.computedData$}).pipe(o(1)),L=et({computedAxesData$:y}).pipe(o(1)),g=rt({computedData$:a.computedData$,isSeriesSeprate$:t}).pipe(o(1)),u=ot({computedData$:a.computedData$,fullDataFormatter$:a.fullDataFormatter$}).pipe(o(1)),D=x({computedData$:a.computedData$,groupScaleDomainValue$:u}).pipe(o(1)),M=x({computedData$:g,groupScaleDomainValue$:u}).pipe(o(1)),d=st({fullDataFormatter$:a.fullDataFormatter$,layout$:a.layout$}).pipe(o(1)),_=it({gridAxesTransform$:d}).pipe(o(1)),A=nt({computedData$:a.computedData$,groupScaleDomainValue$:u,filteredMinMaxValue$:D,fullDataFormatter$:a.fullDataFormatter$,layout$:a.layout$}).pipe(o(1)),V=lt({gridContainerPosition$:s,gridAxesTransform$:d,gridGraphicTransform$:A}).pipe(o(1));return{fullParams$:a.fullParams$,fullChartParams$:a.fullChartParams$,fullDataFormatter$:a.fullDataFormatter$,computedData$:a.computedData$,layout$:a.layout$,textSizePx$:e,isSeriesSeprate$:t,gridContainerPosition$:s,containerSize$:i,gridAxesSize$:$,gridAxesContainerSize$:P,gridHighlight$:h,seriesLabels$:O,SeriesDataMap$:F,GroupDataMap$:R,computedAxesData$:y,visibleComputedData$:G,visibleComputedAxesData$:L,computedStackedData$:g,groupScaleDomainValue$:u,filteredMinMaxValue$:D,filteredStackedMinMaxValue$:M,gridAxesTransform$:d,gridAxesReverseTransform$:_,gridGraphicTransform$:A,gridGraphicReverseScale$:V}};class Ct extends j{constructor(a,e){super({defaultDataFormatter:N,dataFormatterValidator:dt,computedDataFn:ut,dataValidator:ft,contextObserverCallback:yt},a,e)}}const b="Bars",gt={name:b,defaultParams:X,layerIndex:H,validator:(r,{validateColumns:a})=>a(r,{barWidth:{toBeTypes:["number"]},barPadding:{toBeTypes:["number"]},barGroupPadding:{toBeTypes:["number"]},barRadius:{toBeTypes:["number","boolean"]}})},St=p(gt)(({selection:r,name:a,subject:e,observer:t})=>{const s=new m,i=pt(b,{selection:r,computedData$:t.computedData$,computedAxesData$:t.computedAxesData$,visibleComputedData$:t.visibleComputedData$,visibleComputedAxesData$:t.visibleComputedAxesData$,seriesLabels$:t.seriesLabels$,SeriesDataMap$:t.SeriesDataMap$,GroupDataMap$:t.GroupDataMap$,fullParams$:t.fullParams$,fullChartParams$:t.fullChartParams$,gridAxesTransform$:t.gridAxesTransform$,gridGraphicTransform$:t.gridGraphicTransform$,gridGraphicReverseScale$:t.gridGraphicReverseScale$,gridAxesSize$:t.gridAxesSize$,gridHighlight$:t.gridHighlight$,gridContainerPosition$:t.gridContainerPosition$,isSeriesSeprate$:t.isSeriesSeprate$,event$:e.event$});return()=>{s.next(void 0),i()}}),B="GroupAxis",Dt={name:B,defaultParams:Y,layerIndex:T,validator:(r,{validateColumns:a})=>a(r,{labelOffset:{toBe:"[number, number]",test:t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="number"&&typeof t[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBe:'number | null | "all"',test:t=>t===null||t==="all"||typeof t=="number"}})},Pt=p(Dt)(({selection:r,name:a,observer:e,subject:t})=>{const s=new m,i=mt(B,{selection:r,computedData$:e.computedData$,fullParams$:e.fullParams$,fullDataFormatter$:e.fullDataFormatter$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridAxesReverseTransform$:e.gridAxesReverseTransform$,gridAxesSize$:e.gridAxesSize$,gridContainerPosition$:e.gridContainerPosition$,isSeriesSeprate$:e.isSeriesSeprate$,textSizePx$:e.textSizePx$});return()=>{s.next(void 0),i()}}),C="ValueAxis",At={name:C,defaultParams:W,layerIndex:T,validator:(r,{validateColumns:a})=>a(r,{labelOffset:{toBe:"[number, number]",test:t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="number"&&typeof t[1]=="number"},labelColorType:{toBeOption:"ColorType"},axisLineVisible:{toBeTypes:["boolean"]},axisLineColorType:{toBeOption:"ColorType"},ticks:{toBeTypes:["number","null"]},tickFormat:{toBeTypes:["string","Function"]},tickLineVisible:{toBeTypes:["boolean"]},tickPadding:{toBeTypes:["number"]},tickFullLine:{toBeTypes:["boolean"]},tickFullLineDasharray:{toBeTypes:["string"]},tickColorType:{toBeOption:"ColorType"},tickTextRotate:{toBeTypes:["number"]},tickTextColorType:{toBeOption:"ColorType"}})},ht=p(At)(({selection:r,name:a,observer:e,subject:t})=>{const s=new m,i=$t(C,{selection:r,computedData$:e.computedData$,filteredMinMaxValue$:e.filteredMinMaxValue$,fullParams$:e.fullParams$,fullDataFormatter$:e.fullDataFormatter$,fullChartParams$:e.fullChartParams$,gridAxesTransform$:e.gridAxesTransform$,gridAxesReverseTransform$:e.gridAxesReverseTransform$,gridAxesSize$:e.gridAxesSize$,gridContainerPosition$:e.gridContainerPosition$,isSeriesSeprate$:e.isSeriesSeprate$});return()=>{s.next(void 0),i()}}),S="GridTooltip",xt={name:S,defaultParams:q,layerIndex:J,validator:(r,{validateColumns:a})=>a(r,{backgroundColorType:{toBeOption:"ColorType"},backgroundOpacity:{toBeTypes:["number"]},strokeColorType:{toBeOption:"ColorType"},offset:{toBe:"[number, number]",test:t=>Array.isArray(t)&&t.length===2&&typeof t[0]=="number"&&typeof t[1]=="number"},padding:{toBeTypes:["number"]},textColorType:{toBeOption:"ColorType"},renderFn:{toBeTypes:["Function"]}})},Ot=p(xt)(({selection:r,rootSelection:a,name:e,subject:t,observer:s})=>{const i=new m,$=ct(S,{rootSelection:a,fullParams$:s.fullParams$,fullChartParams$:s.fullChartParams$,layout$:s.layout$,event$:t.event$});return()=>{i.next(void 0),$()}});export{St as B,Ot as G,ht as V,Pt as a,Ct as b};
